---
title: "Experimenting with Nitro modules"
publishedAt: "2024-11-01"
summary: "Creating my first library with Nitro modules"
---

Hey there! If you're a React Native developer and you follow enough RN engineers on X, you've probably heard about [Nitro](https://github.com/mrousavy/nitro). **Nitro Modules are a new way for building cross-platform libraries for React Native**. It's an alternative to the pre-existing approachs for building libraries using [Native modules](https://reactnative.dev/docs/native-modules-intro), [Turbo modules](https://github.com/reactwg/react-native-new-architecture/blob/main/docs/turbo-modules.md) or [Expo modules](https://docs.expo.dev/modules/overview).

It recently became stable and I thought it would be a good time to experiment with.

## What are the benefits?

- **Statically typed**: TypeScript for the win üí™
- **JSI-based**: it's bridgeless baby üíÅ‚Äç‚ôÄÔ∏è
- **C++ codegen**: thin runtime layer close to zero overhead üöÄ
- **Fast performance**: multiply the speed of execution by 5~15 folds üí®

Check out the [Nitro benchmarks](https://github.com/mrousavy/NitroBenchmarks) to see how it compares to the other approaches.

## What are we building?

I want to build a module that's simple yet useful.

<Alert type="Note">
  **I'm not an experienced library author**. This is gonna be my first time building this kind of project, so I'll be learning along the way. I apologize in advance for any mistakes.
</Alert>

I've chosen to build a module that opens a website in an in-app-browser experience, heavily inspired by the [react-native-inappbrowser-reborn](https://github.com/proyecto26/react-native-inappbrowser) package, commonly referred by the IAB acronym.

üçé For iOS, we'll use [SFSafariViewController](https://developer.apple.com/documentation/safariservices/sfsafariviewcontroller) primitive.

ü§ñ For Android, we'll use [ChromeCustomTabs](https://developer.android.com/reference/androidx/browser/customtabs) primitive.

## Setting up the project

You can use Nitro in an existing app or within a library. I'll be using a new project for this experiment. Luckily, there's a [template](https://github.com/mrousavy/nitro/tree/main/packages/template) that makes it easier to get started.

Make sure you replace all `<<foo>>` with the correct values. Remember to also rename folders.

## Defining specs

We start by defining the specs for our module. These are simple TypeScript interfaces that describe the native module and its methods. Nitrogen will generate the native and C++ code for autolinking based on these specs.

For iOS, you'll have `src/specs/SFSafariViewController.nitro.ts`

```typescript
import type { HybridObject } from 'react-native-nitro-modules'

export interface SFSafariViewController 
    extends HybridObject<{ ios: 'swift' }> {
  present(params: SFSafariViewControllerPresentParams): void
}

export interface SFSafariViewControllerPresentParams {
  url: string
}
```

For Android, you'll have `src/specs/ChromeCustomTabs.nitro.ts`

```typescript
import type { HybridObject } from 'react-native-nitro-modules'

export interface ChromeCustomTabs 
    extends HybridObject<{ android: 'kotlin' }> {
  launch(params: ChromeCustomTabsLaunchParams): void
}
export interface ChromeCustomTabsLaunchParams {
  url: string
}
```

## Update `nitro.json`

Once specs are defined, you can update `nitro.json` to include them.

```json
{
  "cxxNamespace": ["inappbrowser"],
  "ios": {
    "iosModulename": "NitroInAppBrowser"
  },
  "android": {
    "androidNamespace": ["inappbrowser"],
    "androidCxxLibName": "NitroInAppBrowser"
  },
  "autolinking": {
    "SFSafariViewController": { // name used to register the module within registry, must match the name in the specs
      "swift": "HybridSFSafariViewController" // name here must match the class name in the swift module/file
    },
    "ChromeCustomTabs": { // name used to register the module within registry, must match the name in the specs
      "kotlin": "HybridChromeCustomTabs" // name here must match the class name in the kotlin module/file
    }
  },
  "ignorePaths": ["node_modules"]
}
```

## Example

To test your module, you will need a **runnable application**. You can create one in an `/example` folder using either `react-native-community/cli` or `expo-cli`.

```bash
# using react-native-community/cli
npx @react-native-community/cli@latest init NitroInAppBrowser

# using expo-cli
npx create-expo-app@latest NitroInAppBrowser
```

Do some basic setup for the app to run (install pods, etc).

Install the local module in the example app. You can either use `link:../` or `file:../` version in package.json. Some links about using local modules:

- https://docs.npmjs.com/cli/v7/configuring-npm/package-json#local-paths
- https://stackoverflow.com/questions/20888576/how-to-develop-npm-module-locally

I later found out that using `link` was causing issues with the autolinking process ‚Äî so I recommend using the `file` strategy combined with a postinstall `rm -rf` strategy to avoid circular dependencies.

`example/package.json`

```json
"scripts": {
  ...
  "postinstall": "./scripts/postinstall.sh"
},
"dependencies": {
  "react": "18.3.1",
  "react-native": "0.75.4",
  "react-native-in-app-browser": "file:../",
  "react-native-nitro-modules": "*"
},
```

`example/scripts/postinstall.sh`

```bash
#!/bin/bash

folders=(
  "./node_modules/react-native-in-app-browser/example"
  "./node_modules/react-native-in-app-browser/node_modules"
)

for folder in "${folders[@]}"; do
  if [ -d "$folder" ]; then
    echo "Removing $folder"
    rm -rf "$folder"
  else
    echo "Folder $folder does not exist, skipping"
  fi
done

echo "Post-install completed."
exit 0
```

Oh, you'll also need a custom `metro.config.js` to correctly resolve the local module.

`example/metro.config.js`

```javascript
const { getDefaultConfig, mergeConfig } = require('@react-native/metro-config')
const path = require('path')
const escape = require('escape-string-regexp')
const exclusionList = require('metro-config/src/defaults/exclusionList')
const pak = require('../package.json')

const root = path.resolve(__dirname, '..')
const modules = Object.keys({ ...pak.peerDependencies })

/**
 * Metro configuration
 * https://facebook.github.io/metro/docs/configuration
 *
 * @type {import('metro-config').MetroConfig}
 */
const config = {
  watchFolders: [root],

  // We need to make sure that only one version is loaded for peerDependencies
  // So we block them at the root, and alias them to the versions in example's node_modules
  resolver: {
    blacklistRE: exclusionList(
      modules.map(
        (m) =>
          new RegExp(`^${escape(path.join(root, 'node_modules', m))}\\/.*$`)
      )
    ),

    extraNodeModules: modules.reduce((acc, name) => {
      acc[name] = path.join(__dirname, 'node_modules', name)
      return acc
    }, {}),
  },

  transformer: {
    getTransformOptions: async () => ({
      transform: {
        experimentalImportSupport: false,
        inlineRequires: true,
      },
    }),
  },
}

module.exports = mergeConfig(getDefaultConfig(__dirname), config)
```

That should be it! üéâ

Test it by running a local build of the example app and importing a mocked module from your local dependency.

## Implement your native module

Again, I'm not a Swift or Kotlin expert ü§ì

I'm getting help from Cursor, ChatGPT and some GitHub search to implement the native code. <span className="italic text-sm text-gray-400  dark:text-gray-600 font-light">learning the language and concepts during the process...</span>

### Swift

It's time to dive into Apple's modern language. üçé

I like to open the `/example/ios` folder in Xcode and run the app from there. You won't need to link the native module after doing changes because `/examples/node_modules/react-native-in-app-browser` is a symbolic link. üòâ

Implement `HybridSFSafariViewController.swift` by adding inheritance from the C++ generated specs. XCode helps a lot with the autocompletion of missing methods.

**TODO**: explain these
- `hybridContext`
- `memorySize`

`ios/HybridSFSafariViewController.swift`

```swift
import Foundation
import SafariServices

class HybridSFSafariViewController: HybridSFSafariViewControllerSpec {
  var hybridContext = margelo.nitro.HybridContext()
  
  var memorySize: Int {
    return getSizeOf(self)
  }
  
  func present(params: SFSafariViewControllerPresentParams) throws -> Void {
    NSLog("HybridSFSafariViewController.present(url:%@) is being called", params.url)
    
    guard let nativeUrl = URL(string: params.url) else {
      throw NSError(domain: "HybridSFSafariViewController", code: 0, userInfo: [NSLocalizedDescriptionKey: "Invalid URL"])
    }
    
    let safariViewController = SFSafariViewController(url: nativeUrl)
    
    DispatchQueue.main.async {
      if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
         let window = windowScene.windows.first,
         let rootViewController = window.rootViewController {
        let topViewController = rootViewController.topMostViewController()
        topViewController.present(safariViewController, animated: true, completion: nil)
      } else {
        NSLog("Failed to find top view controller to present SFSafariViewController")
      }
    }
  }
}
```

In order for that to work, you'll also need some helper recursive extensions.

`ios/UIViewController+Extensions.swift`

```swift
import UIKit
import SafariServices

extension UIViewController {
  func topMostViewController() -> UIViewController {
    if let presented = self.presentedViewController {
      return presented.topMostViewController()
    }
    
    if let navigation = self as? UINavigationController {
      return navigation.visibleViewController?.topMostViewController() ?? navigation
    }
    
    if let tab = self as? UITabBarController {
      return tab.selectedViewController?.topMostViewController() ?? tab
    }
    
    return self
  }
}
```

### Kotlin

Now, it's time to implement the Android side. ü§ñ

Implement `HybridChromeCustomTabs.kt` in a similar fashion, extending the C++ generated specs, and complying with the interface.

`android/src/main/java/com/margelo/nitro/inappbrowser/HybridChromeCustomTabs.kt`

```kotlin
package com.margelo.nitro.inappbrowser

import android.net.Uri
import android.util.Log
import androidx.browser.customtabs.CustomTabsIntent
import com.margelo.nitro.NitroModules

class HybridChromeCustomTabs : HybridChromeCustomTabsSpec() {
  companion object {
    const val TAG = "HybridChromeCustomTabs"
  }

  override val memorySize: Long
    get() = 0L

  private val applicationContext = NitroModules.applicationContext

  override fun launch(params: ChromeCustomTabsLaunchParams) {
    Log.d(TAG, "launch: ${params.url}")

    val customTabsIntent = CustomTabsIntent.Builder().build()

    try {
      val context = applicationContext?.currentActivity
      if (context == null) {
        Log.e(TAG, "Error launching Custom Tab: Context is null")
        return
      }

      val uri = Uri.parse(params.url)
      if (uri == null) {
        Log.e(TAG, "Error launching Custom Tab: Invalid URL")
        return
      }

      customTabsIntent.launchUrl(context, uri)
    } catch (e: Exception) {
      Log.e(TAG, "Error launching Custom Tab: ${e.message}", e)
    }
  }
}
```

Note that you can access the `applicationContext` from the `NitroModules` class. You don't need to register the kotlin class in `NitroInAppBrowserPackage.java`, that's automatically done by nitrogen autolinking combined with a static java call to `System.loadLibrary("NitroInAppBrowser")`.

## Use the module on the app

Use the native functions within the React Native codebase.

## Old arch vs new arch

TODO: test the module on an old arch app and a new arch app

## Next steps

Using Nitro:
- [ ] Learn about properties getters and setters
- [ ] Learn about events
- [ ] Learn about promises
- [ ] Build a Hybrid view component

## Resources

Nitro modules in the wild:

- https://github.com/patrickkabwe/react-native-nitro-in-app-browser
- https://github.com/BubbleTrouble14/react-native-nitro-bip39

Podcasts and videos about Nitro:

<div className="flex flex-col gap-4">
  <iframe frameborder="no" scrolling="no" seamless src="https://player.simplecast.com/47d79532-dd2b-4642-a60f-c1f6cc985253?dark=true" className="rounded-md w-full md:w-auto h-auto md:h-[200px]" />
  <iframe src="https://www.youtube.com/embed/p54Dcc1FsZk?si=uUeiXpnp20HLYV6c" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowFullScreen className="rounded-md w-full md:w-auto h-auto md:h-[315px]" />
</div>
