---
title: "The Pragmatic Summary"
publishedAt: "2024-11-15"
summary: "My summary of The Pragmatic Programmer book"
---

This is my summary of the book [The Pragmatic Programmer](https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/).

<Highlight color="green">I like to read and make highlights of the parts that I think are most important</Highlight>. This reading approach helps me absorb the content better. This post is a collection of my highlights tailored to my own life and experience.

I've starting reading this book to become a better programmer. This content will be full of <Highlight color="green">tips to incorporate into your own professional life</Highlight>. It also includes some <Tooltip content="ðŸ‘‹ðŸ˜„">tooltips</Tooltip> into some less known words to me. That's a good way to learn new words, specially for a non-native English speaker.

## Preface

Pragmatism is all about the practical side of things, from beliefs and theories to practical consequences and real-world applications.

Pragmatic programmers exibits the following characteristics:

- **Early adopter / faster adapter**: you need to be able to learn new things quickly and adapt to new situations, never stop learning. **Your confidence is born of experience.**
- **Inquisitive**: you ask questions and seek answers, you are <Tooltip content="a person who collects and hoards things, as a hobby.">a pack rat</Tooltip> for small bits of information.
- **Critical thinker**: you rarely take things as given, you question assumptions and challenge the status quo.
- **Realistic**: you don't get caught up in fantasies, you focus on the practical aspects of the situation, with a good feel for how difficult things are, and how long things will take.
- **Jack of all trades**: you don't need to be an expert in everything, but you <Tooltip content="to stay informed or up-to-date about a topic or situation.">keep abreast</Tooltip> of new developments.

Why spend your life developing software unless you care about doing it well? There's no point.

<Alert type="tip">
  Care about your craft. 
</Alert>

Think about what you're doing while you're doing it.

<Alert type="tip">
  Turn off the autopilot and take control. Constantly critique and appraise your work.
</Alert>

It's a continuous process. Great <Tooltip content="a carefully maintained area of grass.">lawns</Tooltip> need small amounts of daily care. _Kaizen_ (æ”¹å–„) is the Japanese concept of continuously making many small improvements.

## Chapter 1: A Pragmatic Philosophy

Pragmatic programmers think beyond the immediate problem. They won't sit idly by and watch their projects fall apart through neglect. They like to keep them <Tooltip content="clean and fresh as if new; spotless.">pristine</Tooltip>, keeping the momentum up.

A big <Tooltip content="an important quality or feature on which a particular thing depends or is based.">cornerstone</Tooltip> of this philosophy is that you need to **take responsibility for yourself and your actions in terms of your career advancement, your project, and your day-to-day work**, not being afraid to admit ignorance or mistakes. No matter how thorough your planning, testing, documentation and automation is, you will always encounter unexpected problems. Pragmatic programmers deal with them professionally by being proactive and taking responsibility.

To achieve this, you must analyze the situation for risks that are beyond your control, admitting it honestly and trying to offer options. Don't blame someone or something else, neither make up lame excuses. It's up to you to provide solutions, not excuses.

<Alert type="tip">
  Instead of excuses, provide options. Don't say it can't be done; explain what can be done.
</Alert>

When you're about to approach someone trying to say why something can't be done, stop and listen to yourself. Talk to the rubber duck on your monitor, or the cat. Does it sound reasonable, or stupid? Run through the conversation in your mind. What is the other person likely to say?

One broken window, left unrepaired, will soon become a haven for vandals. Don't live with broken windows, it can deteriorate functional systems pretty quickly. Fight software entropy.

<Alert type="tip">
  Fix bad designs, wrong decisions, and poor code when you see them.
</Alert>

{/* Stone Soup story. */}

You may be in a situation where you know exactly what needs doing and how to do it. But ask permission to tackle the whole thing and you'll be met with delays and blank stares. Work out what you can reasonable ask for. Develop it well. Once you've got it, show to people, let them marvel. People find it easier to join an ongoing success. Then say _"of course, it would be better if we added ..."_

<Alert type="tip">
  Be a catalyst for change. You can't force change on people. Instead, show them how the future might be and help them participate in creating it.
</Alert>

{/* Boiled Frog story. */}

Don't focus too tighly and forget about the rest of the world. Try to minimize things <Tooltip content="to move closer to someone slowly and quietly, without being noticed.">creeping up on you</Tooltip>. It's often the accumulation of small things that breaks morale and teams. If a frog is put in a pot of boiling water, it will jump out. But if you put it in a pot of cold water and slowly bring the heat up, it will stay in the water until it's too late.

<Alert type="tip">
  Remember the bigger picture. Don't get so engrossed in the details that you forget to check what's happening around you. It's not just about what you personally are doing.
</Alert>

The frog problem is different from the broken windows issue. On the former, people lose the will to fight entropy because they perceive that no one else cares. The frog just doesn't notice the change.

Write good enough software. Good enough does not imply sloppy or poorly code. Give your users the opportunity to participate in the process of deciding when what you've produced is good enough. Good enough for your users, for future maintainers, for your own peace of mind. You'll find that is more productive, your users are happier, and programs are better for short term incubation. How good is good enough?

<Alert type="tip">
  Make quality a requirement issue. Involve your users in determining the project's real quality requirements.
</Alert>

Great software today is often preferable to perfect software tomorrow. If you give your users something to play with early, their feedback will often lead you to a better eventual solution.

Also know when to stop. Don't spoil a perfectly good program by <Tooltip content="too ornate or complicated.">overembellishment</Tooltip> and over-refinement. Keep it simple. Move on, and let your code stand in its own right for a while. It may not be perfect, but don't worry, it could never be perfect.

An investment in knowledge always pays the best interest. That's a quote from Benjamin Franklin - never at a loss for a <Tooltip content="a short, impactful message or speech, often with a moral or spiritual lesson.">pithy homily</Tooltip>. Your knowledge and experience are your most valuable assets. Ben really <Tooltip content="to say or do something exactly right.">hit the nail on the head</Tooltip> with this one. You should treat your knowledge portfolio as a investment. Serious investors invest regularly - as a habit. Diversify. Manage risk. Buy low, sell high. Review and rebalance.

<Alert type="tip">
  Invest regularly in your knowledge portfolio. Make learning a habit.
</Alert>

Learn at least one new language every year. Avoid getting stuck in a <Tooltip content="a situation or routine that feels repetitive, uninteresting, or unchanging.">rut</Tooltip>. Read a technical book each quarter. Read non-technical books too. Take classes. Participate in local user groups. Isolation can be deadly to your career. Experiment with different environments. Stay current. Get wired by participating in newsgroups.

If somebody asks you a question, and you don't know the answer, freely admit it. Don't let it stop there. Take it as a personal challenge to find the answer. Search the web, ask a guru. Decide if you want to ask publicly or privately. If you're emailing, use a meaningful subject line. `Need help!!!` doesn't cut it. Be specific.

Manage your learning time smartly. Always have something to read in an otherwise dead moment. Time spent waiting for doctors and dentists can be a great opportunity to catch up on your reading.

<Alert type="tip">
  Critically analyze what you read and hear. Don't be <Tooltip content="affected or influenced.">swayed</Tooltip> by vendors, media hype, or <Tooltip content="people with intense, fanatical devotion to a particular belief, cause, or ideology.">zealots'</Tooltip> dogma. Analyze information in terms of you and your project.
</Alert>

Communicate! It's better to be looked over than it is to be overlooked. It doesn't matter if you have the best ideas and/or the finest code if you can't communicate about them with other people. Know what you want to say, and plan your message. Write an outline, jot down the ideas you want to communicate. Then, reharse and ask yourself, _"Does this get across whatever I'm trying to say?"_. Refine it until it does.

Know your audience. Understand their needs, interests and capabilities. Form a strong mental picture of your audience. The <Tooltip content="a type of poem or word puzzle where the first letter (or sometimes syllable or word) of each line spells out a word or message vertically.">acrostic</Tooltip> WISDOM may help you remember the key points:

- **W**ho are you talking to? What do you want them to learn?
- **I**nteresting - why should they care?
- **S**ophisticated - is it at the right level?
- **D**etails - do you need to go into much detail?
- **O**ver what period of time should this be communicated?
- **M**otivation - how to keep them listening to you?

<span className="text-sm font-light text-gray-400 dark:text-gray-600">This was slightly modified to fit better into my own experience.</span>

By making the appropriate pitch to each group, you can maximize the chances of your message being heard and acted upon. Make sure that you choose the right moment and medium. Sometimes all it takes is the simple question _"Is this a good time to talk about ...?"_. Make it look good, presentation and delivery are equally important. Produce an stunning output that involves your audience. Encourage people to talk by asking questions. Get back to people.

<Alert type="tip">
  It's both what you say and the way you say it. There's no point in having great ideas if you can't communicate them effectively.
</Alert>

The more effective you communicate, the more influential you become.

## Chapter 2: A Pragmatic Approach

Software development applies certain ideas that are almost <Tooltip content="something that is universally accepted as true, requiring no proof because it's self-evident.">axiomatic</Tooltip>, and processes that are virtually universal, but they're rarely documented as such. This chapter talks about those, such as:

- The evils of duplication
- Orthogonality
- Reversibility
- Tracer bullets
- Prototypes and Post-it Notes
- Domain Languages
- Estimating

{/* The evils of duplication */}

Unfortunately, knowledge isn't stable. It changes, often rapidly. Our understanding of our system changes day by day. It's very easy to duplicate knowledge during those changes. If you have the same thing expressed in two or more places, you change one place, and you have to remember to change the others. This isn't a question of whether you'll remember: it's a question of when you'll forget. Memory is a fragile thing. At these times, you need to make sure that you have a single source of truth.

<Alert type="tip">
  DRY â€” Don't Repeat Yourself. Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.
</Alert>

The DRY principle is a powerful tool to develop software reliably, easier to understand and maintain. Often, duplication arises from:

- **<Tooltip content="something that happens unintentionally or accidentally, often due to a lack of attention or care.">Inadvertent</Tooltip> duplication**: developers don't realize that they're duplicating code, usually because flaws of design and communication.
- **Impatient duplication**: developers get lazy and copy code to get things done easier, or faster because of deadlines and time pressure.
- **Imposed duplication**: developers feel they have no choice, the environment seems to require duplication.
- **Interdeveloper duplication**: multiple people on a team (or different teams) duplicate a piece of knowledge because they don't know about each other's work.

You can overcome these duplication issues with simple techniques. For example, you can use a single source of truth, such as a metadata file that can automatically generate other representations in different formats and languages. If the problem is about communication, programmatic programmers set up forums to discuss common issues. The idea is to facilitate the exchange of knowledge, and make it easier to reuse it.

<Alert type="tip">
  Make it easy to reuse. It it's easy to reuse, people will. Create an environment that supports reuse.
</Alert>

{/* Orthogonality */}

Orthogonality, in computing, references a kind of independence or decoupling. The term is borrowed from geometry. <Highlight color="green">Two or more things are orthogonal if changes in one do not affect any of the others</Highlight>. Move along one of the lines, and your position projected onto the other doesn't change. In an orthogonal system, the database code would be separate from the user interface code. An example of a non-orthogonal system is the helicopter control: an unbelievablyy complex system, where every change impacts all the other inputs. When components of any system are highly interdependent, there is no such thing as a local fix. In software development, we often want to avoid this kind of non-orthogonal behavior.

<Alert type="tip">
  Eliminate effects between unrelated things. Design components that are self-contained, independent, and have a single, well-defined purpose.
</Alert>

You get two major benefits if you write orthogonal code: increased productivity and reduced risk. Changes are localized. You get more functionality per unit effort by combining orthogonal components. To achieve that, organize code and teams into groups with well-defined responsabilities and minimal overlap. Start by separating infrastructure from application. Orthogonal teams are more efficient, encourage subteams to communicate constantly with each other.

To design orthogonal systems, organize components into layers. An easy test for orthogonal designs is to ask "If I change X, will it affect Y?" If the answer is "None", then X and Y are orthogonal. Also, when you come across a problem, assess how localized the fix is.

{/* Reversibility */}

<Highlight color="green">Nothing is more dangerous than an idea when it's the only one you have</Highlight>. We don't always make the best decisions the first time around, so be prepared to reverse your decisions. Don't assume that a decision is cast in stone, instead, think about decisions as being written in the sand at the beach. It's a mistake to not be prepared for the contingencies that will arise. Think about them up front. Use encapsulation, lightweight coupling and metadata to help you abstract vendors, technologies and whatnot. No one knows what the future may hold.

<Alert type="tip">
  There are no final decisions. Plan for change.
</Alert>

{/* Tracer bullets */}

Tracer bullets are a technique to help you identify the target while shooting. It's very similar to proof of concepts, users get to see something working early and developers build a structure to work in. It doesn't always hit the target, but it helps you identify the direction. You use this technique in situations where you're not 100% certain of where you're going. Gather feedback early and often.

<Alert type="tip">
  Use tracer bullets to find the target by trying things and seeing how close they land.
</Alert>

{/* Prototypes and Post-it Notes */}

Prototyping is different because you throw away whatever you lashed together when trying out the concept, and recode it properly using the lessons you've learned. Prototype anything that carries a large amount of risk. Prototyping generates disposable code. Tracer code is lean but complete, and forms part of the skeleton of the final system.

<Alert type="tip">
  Prototype to learn. Its value lies not in the code you produce, but in the lessons you learn.
</Alert>

{/* Domain languages */}

Domain languages are specialized languages that are used to solve a particular problem. They are often used to describe the problem domain in a way that is more natural and easier to understand than traditional languages. Languages influence how you think about a problem, and how you think about communication. Choose the right language for the job. You wouldn't use a SQL-like language to write a concurrent program.

<Alert type="tip">
  Program close to the problem domain. Design and code in your user's language.
</Alert>

{/* Estimating */}

<Highlight color="green">How many months will it take to deliver your project?</Highlight> This is one of my favorite questions. All answers are estimates, it's just a matter of how accurate they are. When someone asks you for an estimate, think about the context in which your answer will be taken. Do they need high accuracy, or just a <Tooltip content="a number that is a guess, but one that you believe is near the correct number.">ballpark figure</Tooltip>?

<Alert type="tip">
  Estimate before you start. You'll spot potential problems up front.
</Alert>

First, understand what's being asked. Have a <Tooltip content="a general understanding or impression of something.">grasp</Tooltip> of the scope of the domain. _"Assuming there are no traffic accidents and there's gas in the car, I should be there in 20 minutes"_. Then, build a rough <Tooltip content="a basic or simplified version of something that lacks many of the details or features of the original.">bare-bones mental model</Tooltip>. For a project, the model may be the steps that your organization uses during development, along with a very rough picture of how the system might be implemented. Once you have a model, you can decompose it into components. Each component typically have parameters that affect how it contributes to the overall model. Identify each parameter. Give each parameter a value. Work out which parameters have the most impact on the result.

The units you use make a difference. Choose the units of your answer to reflect the accuracy you intend to convey. This time scale is recommended by the book:

<Table
  data={{
    headers: ["Duration", "Quote estimate in"],
    rows: [
      ["1-15 days", "days"],
      ["3-8 weeks", "weeks"],
      ["8-30 weeks", "months"],
      ["30+ weeks", "think hard before giving an estimate"],
    ],
  }}
/>

<Highlight color="green">Start keeping a log of your estimates</Highlight>. For each, track how accurate you turned out to be. If your error was greater than 50%, try to find out where your estimate went wrong. A spreadsheet can be a big help.

<Alert type="tip">
  Iterate the schedule with the code. Use experience you gain as you implement to refine the project time scales.
</Alert>

When someone asks you for an estimate, you say _"I'll get back to you"_. You get better results if you slow the process down and spend some going through the steps above.

## Chapter 3: The Basic Tools

Having a basic set of good-quality tools is key to every developer. Tools are the extensions of your brain. They amplify your talent. The better your tools, and the better you know how to use them, the more productive you can be. Expect to add to your toolbox regularly. Let need drive your acquisitions. Always be on the lookout for better ways of doing things.

Programmers' base material is knowledge. We gather requirements as knowledge, and then express that knowledge in our design, implementation, tests and documents. Plain text is the best format for storing knowledge, that way give ourselves the ability to manipulate it both manually and programmatically. Plain text is made up of printable characters in a form that can be read and understood by humans.

<Alert type="tip">
  Keep knowledge in plain text. It won't become obsolete. It helps leverage your work and simplifies debugging and testing.
</Alert>

Play around with your command shell. Invest some energy in becoming proficient. Learn basic yet useful commands, like <Tooltip content="a command for searching plain-text data sets for lines that match a regular expression pattern.">`grep`</Tooltip>, <Tooltip content="a command for searching for files in a directory hierarchy.">`find`</Tooltip>, <Tooltip content="a command for filtering text data based on patterns.">`sed`</Tooltip> and <Tooltip content="a command for sorting lines of text.">`sort`</Tooltip>.

<Alert type="tip">
  Use the power of command shells when graphical user interfaces don't cut it.
</Alert>

Also learn regular expressions. They are a powerful tool to find and manipulate text.

You need to manipulate text as effortlessly as possible. Use a single editor (or set of keybindings) across all text editing activities. Some options include Vim, Emacs, VSCode, Cursor AI.

<Alert type="tip">
  Use a single editor well. The editor should be an extension of your hand; make sure your editor is configurable, extensible and programmable.
</Alert>

It should offer some basic features:

- Syntax highlighting
- Auto-completion
- Auto-indentation
- Initial code or boilerplate for your language
- IDE-like features (compile, run, debug)

Always use source code control. With git, you can always go back to a previous version of your software. It helps answer questions such as: Who made changes in this line of code? What's the difference between the current version and last week's? How many lines of code did we change in this release? Which files get changed most often? This kind of information is <Tooltip content="of great value.">invaluable</Tooltip> for bug-tracking, audit, performance and quality purposes.

No one writes perfect software. Bugs are a certainty. These software defects manifest themselves in a variety of ways, from misunderstood requirements to coding errors. Debugging those errors is just problem solving. Concentrate on fixing the problem, not the blame. Also, be sure that you're attacking the root of the problem, not just the symptoms.

<Alert type="tip">
  Fix the problem, not the blame. It doesn't really matter whether the bug is your fault or someone else's â€” it is still your problem, and it needs to be fixed.
</Alert>

Always interview the user who reported the bug in order to gather more data than you were initially given. You must brutally test both boundary conditions and realistic end-user usage patterns. Bug reproduction is key. The best way to start fixing a bug is to make it reproducible. Sometimes, by forcing yourself to isolate the circumstances that display the bug, you'll even gain an insight on how to fix it. Visualize your data, use a debugging tool. Analyze stack traces. Add tracing statements as you descend the call tree. Don't panic.

<Alert type="tip">
  Don't panic when debugging. Take a deep breath and think about what could be causing the bug.
</Alert>

Reevaluate truths you hold dear. Don't make assumptions and <Tooltip content="to avoid considering.">gloss over</Tooltip> a routine you "know" is working. Prove it. Prove it in _this_ context, with _this_ data, with _these_ boundary conditions. When you fix a bug, that should be the last time you ever have to deal with it. Add tests so that you don't have to deal with it again. If it took a long time to fix, ask yourself why.

## Chapter 4: Pragmatic Paranoia

As mentioned earlier, an axiom of life is that you can't write perfect software. Accept it and turn that depressing reality into an advantage. Code defensively by not trusting other people's code. If there's any doubt, validate all information you're given. Don't trust yourself either. When everybody is out to get you, paranoia is just good thinking. Play it safe.

{/* Design by Contract */}

Client and suppliers must agree on rights and responsibilities. Design by contract is a way to ensure that both parties understand the expectations and constraints of the relationship. Each party meets its obligations and everyone benefits. Use contracts as a mechanism to write correct program and evaluate its correctness. A correct program is one that does no more and no less than it claims to do. Those expectations and claims are described as follows:

- **Preconditions**: the assumptions that must be true before the program is executed.
- **Postconditions**: the promises that must be true after the program is executed.
- **Invariants**: the assumptions that must be true during the program's execution.

Be strict in what you will accept before you begin, and promise as little as possible in return. Simply enumerate at design time what the input range is, what the boundary conditions are, and what the routine promises to deliver â€” or, more importantly, what it doesn't promise to deliver â€” and you're on your way to write better software.

Have the compiler check your contracts for you. Inheritance and polymorphism are the cornerstones of object-oriented languages and an area where contracts can really shine. Specify a contract only once, in the base class, to have it applied to every future subclass automatically.

{/* Dead Programs Tell No Lies */}

Ensure that your code does no damage while you're working the bugs out. Try to check things often and terminate the program if things go <Tooltip content="away from the appropriate, planned, or expected course.">awry</Tooltip>. An easy way to do this is leverage early returns in your code. It's much easier to find and diagnose the problem by crashing early. Dead programs tell no lies.

<Alert type="tip">
  Crash early. A dead program normally does a lot less damage than a crippled one.
</Alert>

{/* Assertive Programming */}

Write code that actively verifies your assumptions with assertions. Don't use assertions instead of actual error handling.

{/* When to Use Exceptions */}

In practice, if you check for every possible error, it often leads to some pretty ugly code with nested `if` branches. Use try-catch blocks to have a clear flow of control and move all the error handling to a single place. If either party fails to live up to the terms of the contract, an exception should be raised, or the program terminates.

One of the problems with exceptions is knowing when to use them. The author believes that they should rarely be used. Exceptions should be reserved for unexpected events. An exception represents an immediate, nonlocal transfer of control, like a cascading `goto`. Programs that use exceptions for their normal processing suffer from readability and maintainability problems.

<Alert type="tip">
  Use exceptions for exceptional problems. Exceptions can suffer from all the readability and maintainability problems of classic spaghetti code. Reverse exceptions for exceptional things.
</Alert>

If an exception is oftenly thrown and adding code to handle these exceptions becomes tedious, consider using error handler routines.

{/* How to Balance Resources */}

When dealing with resources â€” memory, transactions, threads, files, timers â€” you need to balance allocation and deallocation. The author suggests a simple tip:

<Alert type="tip">
  Finish what you start. Where possible, the routine or object that allocates a resource should be responsible for deallocating it.
</Alert>

Encapsulate resources in classes. The constructor provides a mechanism to allocate the resource, and the destructor deallocates it.

For nested allocations, deallocate resources in the opposite order of allocation. When allocating the same set of resources in different places in your code, always allocate them in the same order.

Check the resource balancing. A good place to ensure that resource usage has not increased since the last execution is the main processing loop of a long-running program, like a `server.listen()` call.

## Chapter 5: Bend, or Break

Life doesn't stand still, neither does code. Write code that's as flexible as possible. Otherwise, we may find our code quickly becoming outdated, or too <Tooltip content="hard but liable to break or shatter easily.">brittle</Tooltip> to fix. You need code that will <Tooltip content="adapt oneself to adverse circumstances.">roll with the punches</Tooltip>.

{/* Coupling */}

Organize your code into modules and limit the interaction between them by minimizing coupling. Coupling dependencies increases the risk that an unrelated change somewhere else in the system will affect your code. Traversing relationships between objects directly can quickly lead to a combinatorial explosion of dependency relationships.

When we ask an object for a particular service, we'd like the service to be performed on our behalf. We do not want the object to give us a third-party object that we have to deal with to get the required service.

Keep dependencies to a minimum by following The Law of Demeter for functions. It states that a function should only call functions that are declared in the same class. It tries to prevent you from reaching into an object to gain access to a third object's methods.

<Alert type="tip">
  Minimize coupling between modules. Avoid coupling by writing "shy" code and applying the Law of Demeter.
</Alert>

{/* TODO: explain more about the Law of Demeter here */}

{/* Metaprogramming */}

Write less code. Move details out of the code completely. Make them configurable. Details messes up our pristine code. Everytime we have to make a change to accomodate a new business rule, we run the risk of breaking the system, or introducing a new bug.

You need to make your system highly configurable to a point of easily switching deeply <Tooltip content="firmly fixed or established; difficult to change.">ingrained</Tooltip> items such as choice of algorithms, database products, middleware technology and user-interface style.

{/* Temporal coupling */}

Do you depende on the "tick" coming before the "tack"?

{/* It's just a view */}

Separation of a data model from a view, or presentation, of that model.

{/* Blackboards */}

Meeting place where modules can exchange data anonymously and asynchronously.

## Chapter 6: While You Are Coding

TODO

## Chapter 7: Before the Project

TODO

## Chapter 8: Pragmatic Projects

TODO
